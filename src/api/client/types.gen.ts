// This file is auto-generated by @hey-api/openapi-ts

/**
 * The ID of the author.
 */
export type AuthorId = string;

/**
 * The Audible identifier (ASIN) of the author. Will be null if unknown. Not the Amazon identifier.
 */
export type AuthorAsin = string | null;

/**
 * The name of the author.
 */
export type AuthorName = string;

/**
 * The new description of the author.
 */
export type AuthorDescription = string | null;

/**
 * The absolute path for the author image. This will be in the `metadata/` directory. Will be null if there is no image.
 */
export type AuthorImagePath = string | null;

/**
 * The time (in ms since POSIX epoch) when added to the server.
 */
export type AddedAt = number;

/**
 * The time (in ms since POSIX epoch) when last updated.
 */
export type UpdatedAt = number;

/**
 * The ID of library items after 2.3.0.
 */
export type LibraryItemId = string;

/**
 * The ID of library items on server version 2.2.23 and before.
 */
export type OldLibraryItemId = string | null;

/**
 * The inode of the item in the file system.
 */
export type Inode = string;

/**
 * The ID of the library.
 */
export type LibraryId = string;

/**
 * The ID of the folder.
 */
export type FolderId = string;

/**
 * The type of media, will be book or podcast.
 */
export type MediaType = 'book' | 'podcast';

/**
 * Base library item schema
 */
export type LibraryItemBase = {
    id?: LibraryItemId;
    oldLibraryItemId?: OldLibraryItemId;
    ino?: Inode;
    libraryId?: LibraryId;
    folderId?: FolderId;
    /**
     * The path of the library item on the server.
     */
    path?: string;
    /**
     * The path, relative to the library folder, of the library item.
     */
    relPath?: string;
    /**
     * Whether the library item is a single file in the root of the library folder.
     */
    isFile?: boolean;
    /**
     * The time (in ms since POSIX epoch) when the library item was last modified on disk.
     */
    mtimeMs?: number;
    /**
     * The time (in ms since POSIX epoch) when the library item status was changed on disk.
     */
    ctimeMs?: number;
    /**
     * The time (in ms since POSIX epoch) when the library item was created on disk. Will be 0 if unknown.
     */
    birthtimeMs?: number;
    addedAt?: AddedAt;
    updatedAt?: UpdatedAt;
    /**
     * Whether the library item was scanned and no longer exists.
     */
    isMissing?: boolean;
    /**
     * Whether the library item was scanned and no longer has media files.
     */
    isInvalid?: boolean;
    mediaType?: MediaType;
};

/**
 * The base book metadata object for minified, normal, and extended schemas to inherit from.
 */
export type BookMetadataBase = {
    /**
     * The title of the book. Will be null if unknown.
     */
    title?: string | null;
    /**
     * The subtitle of the book. Will be null if there is no subtitle.
     */
    subtitle?: string | null;
    /**
     * The genres of the book.
     */
    genres?: Array<string>;
    /**
     * The year the book was published. Will be null if unknown.
     */
    publishedYear?: string | null;
    /**
     * The date the book was published. Will be null if unknown.
     */
    publishedDate?: string | null;
    /**
     * The publisher of the book. Will be null if unknown.
     */
    publisher?: string | null;
    /**
     * A description for the book. Will be null if empty.
     */
    description?: string | null;
    /**
     * The ISBN of the book. Will be null if unknown.
     */
    isbn?: string | null;
    /**
     * The ASIN of the book. Will be null if unknown.
     */
    asin?: string | null;
    /**
     * The language of the book. Will be null if unknown.
     */
    language?: string | null;
    /**
     * Whether the book has been marked as explicit.
     */
    explicit?: boolean;
};

/**
 * The minified metadata for a book in the database.
 */
export type BookMetadataMinified = BookMetadataBase & {
    /**
     * The title of the book with any prefix moved to the end.
     */
    titleIgnorePrefix?: string;
    /**
     * The name of the book's author(s).
     */
    authorName?: string;
    /**
     * The name of the book's author(s) with last names first.
     */
    authorNameLF?: string;
    /**
     * The name of the audiobook's narrator(s).
     */
    narratorName?: string;
    /**
     * The name of the book's series.
     */
    seriesName?: string;
};

/**
 * The absolute path on the server of the cover file. Will be null if there is no cover.
 */
export type BookCoverPath = string | null;

/**
 * Tags applied to items.
 */
export type Tags = Array<string>;

/**
 * The total length (in seconds) of the item or file.
 */
export type DurationSec = number;

/**
 * The total size (in bytes) of the item or file.
 */
export type Size = number;

/**
 * Minified book schema. Does not depend on `bookBase` because there's pretty much no overlap.
 */
export type BookMinified = {
    metadata?: BookMetadataMinified;
    coverPath?: BookCoverPath;
    tags?: Tags;
    /**
     * The number of tracks the book's audio files have.
     */
    numTracks?: number;
    /**
     * The number of audio files the book has.
     */
    numAudioFiles?: number;
    /**
     * The number of chapters the book has.
     */
    numChapters?: number;
    /**
     * The total number of missing parts the book has.
     */
    numMissingParts?: number;
    /**
     * The number of invalid audio files the book has.
     */
    numInvalidAudioFiles?: number;
    duration?: DurationSec;
    size?: Size;
    /**
     * The format of ebook of the book. Will be null if the book is an audiobook.
     */
    ebookFormat?: string | null;
};

/**
 * The minified media of the library item.
 */
export type MediaMinified = BookMinified;

/**
 * A single item on the server, like a book or podcast. Minified media format.
 */
export type LibraryItemMinified = LibraryItemBase & {
    media?: MediaMinified;
};

/**
 * The ID of the series.
 */
export type SeriesId = string;

/**
 * The name of the series.
 */
export type SeriesName = string;

/**
 * Series and the included library items that an author has written.
 */
export type AuthorSeries = {
    id?: SeriesId;
    name?: SeriesName;
    /**
     * The items in the series. Each library item's media's metadata will have a `series` attribute, a `Series Sequence`, which is the matching series.
     */
    items?: Array<LibraryItemMinified>;
};

/**
 * An author object which includes a description and image path. The library items and series associated with the author are optionally included.
 */
export type Author = {
    id?: AuthorId;
    asin?: AuthorAsin;
    name?: AuthorName;
    description?: AuthorDescription;
    imagePath?: AuthorImagePath;
    addedAt?: AddedAt;
    updatedAt?: UpdatedAt;
    /**
     * The items associated with the author
     */
    libraryItems?: Array<LibraryItemMinified>;
    /**
     * The series associated with the author
     */
    series?: Array<AuthorSeries>;
};

/**
 * Whether the author was updated without errors. Will not exist if author was merged.
 */
export type AuthorUpdated = boolean | null;

/**
 * Whether the author was merged with another author. Will not exist if author was updated.
 */
export type AuthorMerged = boolean | null;

/**
 * The requested width of image in pixels.
 */
export type ImageWidth = number;

/**
 * The requested height of image in pixels. If `null`, the height is scaled to maintain aspect ratio based on the requested width.
 */
export type ImageHeight = number | null;

/**
 * The requested output format.
 */
export type ImageFormat = string;

/**
 * Return the raw image without scaling if true.
 */
export type ImageRaw = boolean;

/**
 * The URL of the image to add to the server
 */
export type ImageUrl = string;

/**
 * The name of the author to use for searching.
 */
export type AuthorSearchName = string;

/**
 * The region used to search.
 */
export type Region = string;

/**
 * The name of the e-reader device.
 */
export type EreaderName = string;

/**
 * An e-reader device configured to receive EPUB through e-mail.
 */
export type EreaderDeviceObject = {
    name: EreaderName;
    /**
     * The email address associated with the e-reader device.
     */
    email: string;
    /**
     * The availability option for the device.
     */
    availabilityOption: 'adminOrUp' | 'userOrUp' | 'guestOrUp' | 'specificUsers';
    /**
     * List of specific users allowed to access the device.
     */
    users?: Array<string>;
};

/**
 * The email settings configuration for the server. This includes the credentials to send e-books and an array of e-reader devices.
 */
export type EmailSettings = {
    /**
     * The unique identifier for the email settings. Currently this is always `email-settings`
     */
    id: string;
    /**
     * The SMTP host address.
     */
    host?: string | null;
    /**
     * The port number for the SMTP server.
     */
    port: number;
    /**
     * Indicates if the connection should use SSL/TLS.
     */
    secure: boolean;
    /**
     * Indicates if unauthorized SSL/TLS certificates should be rejected.
     */
    rejectUnauthorized?: boolean;
    /**
     * The username for SMTP authentication.
     */
    user?: string | null;
    /**
     * The password for SMTP authentication.
     */
    pass?: string | null;
    /**
     * The test email address used for sending test emails.
     */
    testAddress?: string | null;
    /**
     * The default "from" email address for outgoing emails.
     */
    fromAddress?: string | null;
    /**
     * List of configured e-reader devices.
     */
    ereaderDevices: Array<EreaderDeviceObject>;
};

/**
 * The name of the library.
 */
export type LibraryName = string;

/**
 * Folder used in library
 */
export type Folder = {
    id?: FolderId;
    /**
     * The path on the server for the folder. (Read Only)
     */
    fullPath?: string;
    libraryId?: LibraryId;
    addedAt?: AddedAt;
};

/**
 * The settings for the library.
 */
export type LibrarySettings = {
    /**
     * Whether the library should use square book covers. Must be 0 (for false) or 1 (for true).
     */
    coverAspectRatio?: number;
    /**
     * Whether to disable the folder watcher for the library.
     */
    disableWatcher?: boolean;
    /**
     * Whether to skip matching books that already have an ASIN.
     */
    skipMatchingMediaWithAsin?: boolean;
    /**
     * Whether to skip matching books that already have an ISBN.
     */
    skipMatchingMediaWithIsbn?: boolean;
    /**
     * The cron expression for when to automatically scan the library folders. If null, automatic scanning will be disabled.
     */
    autoScanCronExpression?: string | null;
    /**
     * Whether the library should ignore ebook files and only allow ebook files to be supplementary.
     */
    audiobooksOnly?: boolean;
    /**
     * Whether to hide series with only one book.
     */
    hideSingleBookSeries?: boolean;
    /**
     * Whether to only show books in a series after the highest series sequence.
     */
    onlyShowLaterBooksInContinueSeries?: boolean;
    /**
     * The precedence of metadata sources. See Metadata Providers for a list of possible providers.
     */
    metadataPrecedence?: Array<string>;
    /**
     * The region to use when searching for podcasts.
     */
    podcastSearchRegion?: string;
};

/**
 * The time (in ms since POSIX epoch) when was created.
 */
export type CreatedAt = number;

/**
 * A library object which includes either books or podcasts.
 */
export type Library = {
    id?: LibraryId;
    name?: LibraryName;
    /**
     * The folders that belong to the library.
     */
    folders?: Array<Folder>;
    /**
     * Display position of the library in the list of libraries. Must be >= 1.
     */
    displayOrder?: number;
    /**
     * The selected icon for the library. See Library Icons for a list of possible icons.
     */
    icon?: string;
    /**
     * The type of media that the library contains. Will be `book` or `podcast`. (Read Only)
     */
    mediaType?: string;
    /**
     * Preferred metadata provider for the library. See Metadata Providers for a list of possible providers.
     */
    provider?: string;
    settings?: LibrarySettings;
    createdAt?: CreatedAt;
    lastUpdate?: UpdatedAt;
};

/**
 * The folders of the library. Only specify the fullPath.
 */
export type LibraryFolders = Array<Folder>;

/**
 * The display order of the library. Must be >= 1.
 */
export type LibraryDisplayOrder = number;

/**
 * The icon of the library. See Library Icons for a list of possible icons.
 */
export type LibraryIcon = string;

/**
 * The type of media that the library contains. Must be `book` or `podcast`.
 */
export type LibraryMediaType = string;

/**
 * Preferred metadata provider for the library. See Metadata Providers for a list of possible providers.
 */
export type LibraryProvider = string;

/**
 * The author schema with the total number of books in the library.
 */
export type AuthorExpanded = Author & {
    /**
     * The number of books associated with the author in the library.
     */
    numBooks?: number;
};

/**
 * The total number of items in the response.
 */
export type Total = number;

/**
 * The number of items to return. If 0, no items are returned.
 */
export type Limit = number;

/**
 * The page number (zero indexed) to return. If no limit is specified, then page will have no effect.
 */
export type Page = number;

/**
 * The field to sort by from the request.
 */
export type SortBy = string;

/**
 * Whether to sort in descending order.
 */
export type SortDesc = boolean;

/**
 * The field to filter by from the request. TODO
 */
export type FilterBy = string;

/**
 * Return minified items if true.
 */
export type Minified = boolean;

/**
 * Whether collapse series was set in the request.
 */
export type CollapseSeries = boolean;

/**
 * The fields to include in the response. The only current option is `rssfeed`.
 */
export type LibraryInclude = string;

/**
 * The position in the series the book is.
 */
export type Sequence = string | null;

/**
 * A single item on the server, like a book or podcast. Includes series sequence information.
 */
export type LibraryItemSequence = LibraryItemBase & {
    sequence?: Sequence;
};

/**
 * A series object which includes the name and books in the series.
 */
export type SeriesBooks = {
    id?: SeriesId;
    name?: SeriesName;
    addedAt?: AddedAt;
    /**
     * The name of the series with any prefix moved to the end.
     */
    nameIgnorePrefix?: string;
    /**
     * The name of the series with any prefix removed.
     */
    nameIgnorePrefixSort?: string;
    /**
     * Will always be `series`.
     */
    type?: string;
    /**
     * The library items that contain the books in the series. A sequence attribute that denotes the position in the series the book is in, is tacked on.
     */
    books?: Array<LibraryItemSequence>;
    /**
     * The combined duration (in seconds) of all books in the series.
     */
    totalDuration?: number;
};

/**
 * A description for the series. Will be null if there is none.
 */
export type SeriesDescription = string | null;

/**
 * A series object which includes the name and description of the series.
 */
export type Series = {
    id?: SeriesId;
    name?: SeriesName;
    description?: SeriesDescription;
    addedAt?: AddedAt;
    updatedAt?: UpdatedAt;
};

/**
 * The user's progress of a series.
 */
export type SeriesProgress = {
    /**
     * The IDs of the library items in the series.
     */
    libraryItemIds?: Array<LibraryItemId>;
    /**
     * The IDs of the library items in the series that are finished.
     */
    libraryItemIdsFinished?: Array<LibraryItemId>;
    /**
     * Whether the series is finished.
     */
    isFinished?: boolean;
};

/**
 * A series object which includes the name and progress of the series.
 */
export type SeriesWithProgressAndRss = Series | {
    progress?: SeriesProgress;
    /**
     * The RSS feed for the series.
     */
    rssFeed?: string;
};

export type NotificationEvent = {
    /**
     * The name of the notification event. The names and allowable values are defined at https://github.com/advplyr/audiobookshelf/blob/master/server/utils/notifications.js
     */
    name?: string;
    /**
     * Whether the notification event depends on a library existing.
     */
    requiresLibrary?: boolean;
    /**
     * The type of media of the library the notification depends on existing. Will not exist if requiresLibrary is false.
     */
    libraryMediaType?: string | null;
    /**
     * The description of the notification event.
     */
    description?: string;
    /**
     * The variables of the notification event that can be used in the notification templates.
     */
    variables?: Array<string>;
    defaults?: {
        /**
         * The default title template for notifications using the notification event.
         */
        title?: string;
        /**
         * The default body template for notifications using the notification event.
         */
        body?: string;
    };
    /**
     * The keys of the testData object will match the list of variables. The values will be the data used when sending a test notification.
     */
    testData?: {
        [key: string]: string;
    };
};

/**
 * The ID of the notification.
 */
export type NotificationId = string;

/**
 * The full URL where the Apprise API to use is located.
 */
export type AppriseApiUrl = string | null;

/**
 * The ID of the library. Applies to all libraries if `null`.
 */
export type LibraryIdNullable = string | null;

/**
 * The name of the event the notification will fire on.
 */
export type NotificationEventName = 'onPodcastEpisodeDownloaded' | 'onBackupCompleted' | 'onBackupFailed' | 'onTest';

/**
 * The Apprise URLs to use for the notification.
 */
export type Urls = Array<string>;

/**
 * The template for the notification title.
 */
export type TitleTemplate = string;

/**
 * The template for the notification body.
 */
export type BodyTemplate = string;

/**
 * Whether the notification is enabled.
 */
export type Enabled = boolean;

/**
 * The notification's type.
 */
export type NotificationType = 'info' | 'success' | 'warning' | 'failure';

export type Notification = {
    id?: NotificationId;
    libraryId?: LibraryIdNullable;
    eventName?: NotificationEventName;
    urls?: Urls;
    titleTemplate?: TitleTemplate;
    bodyTemplate?: BodyTemplate;
    enabled?: Enabled;
    type?: NotificationType;
    /**
     * The time (in ms since POSIX epoch) when the notification was last fired. Will be null if the notification has not fired.
     */
    lastFiredAt?: number | null;
    /**
     * Whether the last notification attempt failed.
     */
    lastAttemptFailed?: boolean;
    /**
     * The number of consecutive times the notification has failed.
     */
    numConsecutiveFailedAttempts?: number;
    /**
     * The number of times the notification has fired.
     */
    numTimesFired?: number;
    createdAt?: CreatedAt;
};

/**
 * The maximum number of times a notification fails before being disabled.
 */
export type MaxFailedAttempts = number;

/**
 * The maximum number of notifications in the notification queue before events are ignored.
 */
export type MaxNotificationQueue = number;

export type NotificationSettings = {
    id?: NotificationId;
    /**
     * The type of Apprise that will be used. At the moment, only api is available.
     */
    appriseType?: string;
    appriseApiUrl?: AppriseApiUrl;
    /**
     * The set notifications.
     */
    notifications?: Array<Notification>;
    maxFailedAttempts?: MaxFailedAttempts;
    maxNotificationQueue?: MaxNotificationQueue;
    /**
     * The time (in ms) between notification pushes.
     */
    notificationDelay?: number;
};

/**
 * The ID of podcasts and podcast episodes after 2.3.0.
 */
export type PodcastId = string;

/**
 * Metadata for a podcast.
 */
export type PodcastMetadata = {
    /**
     * The title of the podcast.
     */
    title?: string | null;
    /**
     * The author of the podcast.
     */
    author?: string | null;
    /**
     * The description of the podcast.
     */
    description?: string | null;
    /**
     * The release date of the podcast.
     */
    releaseDate?: string | null;
    /**
     * The genres of the podcast.
     */
    genres?: Array<string>;
    /**
     * The URL of the podcast feed.
     */
    feedUrl?: string | null;
    /**
     * The URL of the podcast's image.
     */
    imageUrl?: string | null;
    /**
     * The URL of the podcast's iTunes page.
     */
    itunesPageUrl?: string | null;
    /**
     * The iTunes ID of the podcast.
     */
    itunesId?: string | null;
    /**
     * The iTunes artist ID of the podcast.
     */
    itunesArtistId?: string | null;
    /**
     * Whether the podcast contains explicit content.
     */
    explicit?: boolean;
    /**
     * The language of the podcast.
     */
    language?: string | null;
    /**
     * The type of podcast (e.g., episodic, serial).
     */
    type?: string | null;
};

/**
 * The ID of podcasts on server version 2.2.23 and before.
 */
export type OldPodcastId = string | null;

/**
 * The metadata for a file, including the path, size, and unix timestamps of the file.
 */
export type FileMetadata = {
    /**
     * The filename of the file.
     */
    filename?: string;
    /**
     * The file extension of the file.
     */
    ext?: string;
    /**
     * The absolute path on the server of the file.
     */
    path?: string;
    /**
     * The path of the file, relative to the book's or podcast's folder.
     */
    relPath?: string;
    size?: Size;
    /**
     * The time (in ms since POSIX epoch) when the file was last modified on disk.
     */
    mtimeMs?: number;
    /**
     * The time (in ms since POSIX epoch) when the file status was changed on disk.
     */
    ctimeMs?: number;
    /**
     * The time (in ms since POSIX epoch) when the file was created on disk. Will be 0 if unknown.
     */
    birthtimeMs?: number;
} | null;

/**
 * A book chapter. Includes the title and timestamps.
 */
export type BookChapter = {
    /**
     * The ID of the book chapter.
     */
    id?: number;
    /**
     * When in the book (in seconds) the chapter starts.
     */
    start?: number;
    /**
     * When in the book (in seconds) the chapter ends.
     */
    end?: number;
    /**
     * The title of the chapter.
     */
    title?: string;
};

/**
 * ID3 metadata tags pulled from the audio file on import. Only non-null tags will be returned in requests.
 */
export type AudioMetaTags = {
    tagAlbum?: string | null;
    tagArtist?: string | null;
    tagGenre?: string | null;
    tagTitle?: string | null;
    tagSeries?: string | null;
    tagSeriesPart?: string | null;
    tagTrack?: string | null;
    tagDisc?: string | null;
    tagSubtitle?: string | null;
    tagAlbumArtist?: string | null;
    tagDate?: string | null;
    tagComposer?: string | null;
    tagPublisher?: string | null;
    tagComment?: string | null;
    tagDescription?: string | null;
    tagEncoder?: string | null;
    tagEncodedBy?: string | null;
    tagIsbn?: string | null;
    tagLanguage?: string | null;
    tagASIN?: string | null;
    tagOverdriveMediaMarker?: string | null;
    tagOriginalYear?: string | null;
    tagReleaseCountry?: string | null;
    tagReleaseType?: string | null;
    tagReleaseStatus?: string | null;
    tagISRC?: string | null;
    tagMusicBrainzTrackId?: string | null;
    tagMusicBrainzAlbumId?: string | null;
    tagMusicBrainzAlbumArtistId?: string | null;
    tagMusicBrainzArtistId?: string | null;
};

/**
 * An audio file for a book. Includes audio metadata and track numbers.
 */
export type AudioFile = {
    /**
     * The index of the audio file.
     */
    index?: number;
    ino?: Inode;
    metadata?: FileMetadata;
    addedAt?: AddedAt;
    updatedAt?: UpdatedAt;
    /**
     * The track number of the audio file as pulled from the file's metadata. Will be null if unknown.
     */
    trackNumFromMeta?: number | null;
    /**
     * The disc number of the audio file as pulled from the file's metadata. Will be null if unknown.
     */
    discNumFromMeta?: string | null;
    /**
     * The track number of the audio file as determined from the file's name. Will be null if unknown.
     */
    trackNumFromFilename?: number | null;
    /**
     * The disc number of the audio file as determined from the file's name. Will be null if unknown.
     */
    discNumFromFilename?: string | null;
    /**
     * Whether the audio file has been manually verified by a user.
     */
    manuallyVerified?: boolean;
    /**
     * Whether the audio file is missing from the server.
     */
    invalid?: boolean;
    /**
     * Whether the audio file has been marked for exclusion.
     */
    exclude?: boolean;
    /**
     * Any error with the audio file. Will be null if there is none.
     */
    error?: string | null;
    /**
     * The format of the audio file.
     */
    format?: string;
    duration?: DurationSec;
    /**
     * The bit rate (in bit/s) of the audio file.
     */
    bitRate?: number;
    /**
     * The language of the audio file.
     */
    language?: string | null;
    /**
     * The codec of the audio file.
     */
    codec?: string;
    /**
     * The time base of the audio file.
     */
    timeBase?: string;
    /**
     * The number of channels the audio file has.
     */
    channels?: number;
    /**
     * The layout of the audio file's channels.
     */
    channelLayout?: string;
    /**
     * If the audio file is part of an audiobook, the chapters the file contains.
     */
    chapters?: Array<BookChapter>;
    /**
     * The type of embedded cover art in the audio file. Will be null if none exists.
     */
    embeddedCoverArt?: string | null;
    metaTags?: AudioMetaTags;
    /**
     * The MIME type of the audio file.
     */
    mimeType?: string;
};

/**
 * Represents an audio track with various properties.
 */
export type AudioTrack = {
    /**
     * The index of the audio track.
     */
    index?: number | null;
    /**
     * The start offset of the audio track in seconds.
     */
    startOffset?: number | null;
    /**
     * The duration of the audio track in seconds.
     */
    duration?: number | null;
    /**
     * The title of the audio track.
     */
    title?: string | null;
    /**
     * The URL where the audio track content is located.
     */
    contentUrl?: string | null;
    /**
     * The MIME type of the audio track.
     */
    mimeType?: string | null;
    /**
     * The codec used for the audio track.
     */
    codec?: string | null;
    metadata?: FileMetadata;
};

/**
 * A single episode of a podcast.
 */
export type PodcastEpisode = {
    libraryItemId?: LibraryItemId;
    podcastId?: PodcastId;
    id?: PodcastId;
    oldEpisodeId?: OldPodcastId;
    /**
     * The index of the episode within the podcast.
     */
    index?: number | null;
    /**
     * The season number of the episode.
     */
    season?: string | null;
    /**
     * The episode number within the season.
     */
    episode?: string | null;
    /**
     * The type of episode (e.g., full, trailer).
     */
    episodeType?: string | null;
    /**
     * The title of the episode.
     */
    title?: string | null;
    /**
     * The subtitle of the episode.
     */
    subtitle?: string | null;
    /**
     * The description of the episode.
     */
    description?: string | null;
    /**
     * The enclosure object containing additional episode data.
     */
    enclosure?: {
        [key: string]: unknown;
    } | null;
    /**
     * The globally unique identifier for the episode.
     */
    guid?: string | null;
    /**
     * The publication date of the episode.
     */
    pubDate?: string | null;
    /**
     * The chapters within the episode.
     */
    chapters?: Array<{
        [key: string]: unknown;
    }>;
    audioFile?: AudioFile;
    publishedAt?: CreatedAt;
    addedAt?: AddedAt;
    updatedAt?: UpdatedAt;
    audioTrack?: AudioTrack;
    duration?: DurationSec;
    size?: Size;
};

/**
 * Whether episodes are automatically downloaded.
 */
export type AutoDownloadEpisodes = boolean;

/**
 * A podcast containing multiple episodes.
 */
export type Podcast = {
    id?: PodcastId;
    libraryItemId?: LibraryItemId;
    metadata?: PodcastMetadata;
    /**
     * The file path to the podcast's cover image.
     */
    coverPath?: string | null;
    /**
     * The tags associated with the podcast.
     */
    tags?: Array<string>;
    /**
     * The episodes of the podcast.
     */
    episodes?: Array<PodcastEpisode>;
    autoDownloadEpisodes?: AutoDownloadEpisodes;
    /**
     * The schedule for automatic episode downloads, in cron format.
     */
    autoDownloadSchedule?: string | null;
    /**
     * The timestamp of the last episode check.
     */
    lastEpisodeCheck?: number;
    /**
     * The maximum number of episodes to keep.
     */
    maxEpisodesToKeep?: number;
    /**
     * The maximum number of new episodes to download when automatically downloading epsiodes.
     */
    maxNewEpisodesToDownload?: number;
    /**
     * The timestamp of the last cover search.
     */
    lastCoverSearch?: number | null;
    /**
     * The query used for the last cover search.
     */
    lastCoverSearchQuery?: string | null;
    /**
     * The total size of all episodes in bytes.
     */
    size?: number;
    /**
     * The total duration of all episodes in seconds.
     */
    duration?: number;
    /**
     * The number of tracks (episodes) in the podcast.
     */
    numTracks?: number;
    /**
     * The timestamp of the most recently published episode.
     */
    latestEpisodePublished?: number;
};

/**
 * Return minified items if true
 */
export type Minified2 = number;

/**
 * The number of items to return. This the size of a single page for the optional `page` query.
 */
export type Limit2 = number;

/**
 * The page number (zero indexed) to return. If no limit is specified, then page will have no effect.
 */
export type Page2 = number;

/**
 * Return items in reversed order if true.
 */
export type Desc = number;

export type DeleteAuthorByIdData = {
    body?: never;
    path: {
        /**
         * Author ID
         */
        id: AuthorId;
    };
    query?: never;
    url: '/api/authors/{id}';
};

export type DeleteAuthorByIdErrors = {
    /**
     * Author not found.
     */
    404: string;
};

export type DeleteAuthorByIdError = DeleteAuthorByIdErrors[keyof DeleteAuthorByIdErrors];

export type DeleteAuthorByIdResponses = {
    /**
     * deleteAuthorById OK
     */
    200: string;
};

export type DeleteAuthorByIdResponse = DeleteAuthorByIdResponses[keyof DeleteAuthorByIdResponses];

export type GetAuthorByIdData = {
    body?: never;
    path: {
        /**
         * Author ID
         */
        id: AuthorId;
    };
    query?: {
        /**
         * A comma separated list of what to include with the author. The options are `items` and `series`. `series` will only have an effect if `items` is included. For example, the value `items,series` will include both library items and series.
         */
        include?: string;
    };
    url: '/api/authors/{id}';
};

export type GetAuthorByIdErrors = {
    /**
     * Author not found.
     */
    404: string;
};

export type GetAuthorByIdError = GetAuthorByIdErrors[keyof GetAuthorByIdErrors];

export type GetAuthorByIdResponses = {
    /**
     * getAuthorById OK
     */
    200: Author;
};

export type GetAuthorByIdResponse = GetAuthorByIdResponses[keyof GetAuthorByIdResponses];

export type UpdateAuthorByIdData = {
    /**
     * The author object to update.
     */
    body?: {
        name?: AuthorName;
        description?: AuthorDescription;
        imagePath?: AuthorImagePath;
        asin?: AuthorAsin;
    };
    path: {
        /**
         * Author ID
         */
        id: AuthorId;
    };
    query?: never;
    url: '/api/authors/{id}';
};

export type UpdateAuthorByIdErrors = {
    /**
     * Author not found.
     */
    404: string;
};

export type UpdateAuthorByIdError = UpdateAuthorByIdErrors[keyof UpdateAuthorByIdErrors];

export type UpdateAuthorByIdResponses = {
    /**
     * updateAuthorById OK
     */
    200: Author | AuthorUpdated | AuthorMerged;
};

export type UpdateAuthorByIdResponse = UpdateAuthorByIdResponses[keyof UpdateAuthorByIdResponses];

export type DeleteAuthorImageByIdData = {
    body?: never;
    path: {
        /**
         * Author ID
         */
        id: AuthorId;
    };
    query?: {
        /**
         * API token
         */
        token?: string;
        /**
         * Updated at value
         */
        ts?: number;
    };
    url: '/api/authors/{id}/image';
};

export type DeleteAuthorImageByIdErrors = {
    /**
     * Author not found.
     */
    404: string;
};

export type DeleteAuthorImageByIdError = DeleteAuthorImageByIdErrors[keyof DeleteAuthorImageByIdErrors];

export type DeleteAuthorImageByIdResponses = {
    /**
     * deleteAuthorImageById OK
     */
    200: unknown;
};

export type GetAuthorImageByIdData = {
    /**
     * The author image to get.
     */
    body?: {
        width?: ImageWidth;
        height?: ImageHeight;
        format?: ImageFormat;
        raw?: ImageRaw;
    };
    path: {
        /**
         * Author ID
         */
        id: AuthorId;
    };
    query?: {
        /**
         * API token
         */
        token?: string;
        /**
         * Updated at value
         */
        ts?: number;
    };
    url: '/api/authors/{id}/image';
};

export type GetAuthorImageByIdErrors = {
    /**
     * Author not found.
     */
    404: string;
};

export type GetAuthorImageByIdError = GetAuthorImageByIdErrors[keyof GetAuthorImageByIdErrors];

export type GetAuthorImageByIdResponses = {
    /**
     * getAuthorImageById OK
     */
    200: Blob | File;
};

export type GetAuthorImageByIdResponse = GetAuthorImageByIdResponses[keyof GetAuthorImageByIdResponses];

export type UpdateAuthorImageByIdData = {
    /**
     * The author image to update.
     */
    body?: {
        width?: ImageWidth;
        height?: ImageHeight;
        format?: ImageFormat;
        raw?: ImageRaw;
    };
    path: {
        /**
         * Author ID
         */
        id: AuthorId;
    };
    query?: {
        /**
         * API token
         */
        token?: string;
        /**
         * Updated at value
         */
        ts?: number;
    };
    url: '/api/authors/{id}/image';
};

export type UpdateAuthorImageByIdErrors = {
    /**
     * Author not found.
     */
    404: string;
};

export type UpdateAuthorImageByIdError = UpdateAuthorImageByIdErrors[keyof UpdateAuthorImageByIdErrors];

export type UpdateAuthorImageByIdResponses = {
    /**
     * updateAuthorImageById OK
     */
    200: Blob | File;
};

export type UpdateAuthorImageByIdResponse = UpdateAuthorImageByIdResponses[keyof UpdateAuthorImageByIdResponses];

export type AddAuthorImageByIdData = {
    /**
     * The author image to add by URL.
     */
    body: ImageUrl;
    path: {
        /**
         * Author ID
         */
        id: AuthorId;
    };
    query?: {
        /**
         * API token
         */
        token?: string;
        /**
         * Updated at value
         */
        ts?: number;
    };
    url: '/api/authors/{id}/image';
};

export type AddAuthorImageByIdErrors = {
    /**
     * Author not found.
     */
    404: string;
};

export type AddAuthorImageByIdError = AddAuthorImageByIdErrors[keyof AddAuthorImageByIdErrors];

export type AddAuthorImageByIdResponses = {
    /**
     * addAuthorImageById OK
     */
    200: Blob | File;
};

export type AddAuthorImageByIdResponse = AddAuthorImageByIdResponses[keyof AddAuthorImageByIdResponses];

export type MatchAuthorByIdData = {
    /**
     * The author object to match against an online provider.
     */
    body: {
        q?: AuthorSearchName;
        asin?: AuthorAsin;
        region?: Region;
    };
    path: {
        /**
         * Author ID
         */
        id: AuthorId;
    };
    query?: never;
    url: '/api/authors/{id}/match';
};

export type MatchAuthorByIdErrors = {
    /**
     * Author not found.
     */
    404: string;
};

export type MatchAuthorByIdError = MatchAuthorByIdErrors[keyof MatchAuthorByIdErrors];

export type MatchAuthorByIdResponses = {
    /**
     * matchAuthorById OK
     */
    200: Author | AuthorUpdated;
};

export type MatchAuthorByIdResponse = MatchAuthorByIdResponses[keyof MatchAuthorByIdResponses];

export type GetEmailSettingsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/emails/settings';
};

export type GetEmailSettingsResponses = {
    /**
     * Successful response - Email
     */
    200: EmailSettings;
};

export type GetEmailSettingsResponse = GetEmailSettingsResponses[keyof GetEmailSettingsResponses];

export type UpdateEmailSettingsData = {
    body: EmailSettings;
    path?: never;
    query?: never;
    url: '/api/emails/settings';
};

export type UpdateEmailSettingsResponses = {
    /**
     * Successful response - Email
     */
    200: EmailSettings;
};

export type UpdateEmailSettingsResponse = UpdateEmailSettingsResponses[keyof UpdateEmailSettingsResponses];

export type SendTestEmailData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/emails/test';
};

export type SendTestEmailResponses = {
    /**
     * Successful response
     */
    200: unknown;
};

export type UpdateEReaderDevicesData = {
    body: {
        ereaderDevices?: Array<EreaderDeviceObject>;
    };
    path?: never;
    query?: never;
    url: '/api/emails/ereader-devices';
};

export type UpdateEReaderDevicesErrors = {
    /**
     * Invalid payload
     */
    400: unknown;
};

export type UpdateEReaderDevicesResponses = {
    /**
     * Successful response - Ereader
     */
    200: {
        ereaderDevices?: Array<EreaderDeviceObject>;
    };
};

export type UpdateEReaderDevicesResponse = UpdateEReaderDevicesResponses[keyof UpdateEReaderDevicesResponses];

export type SendEBookToDeviceData = {
    body: {
        libraryItemId?: LibraryItemId;
        deviceName?: EreaderName;
    };
    path?: never;
    query?: never;
    url: '/api/emails/send-ebook-to-device';
};

export type SendEBookToDeviceErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Not found
     */
    404: unknown;
};

export type SendEBookToDeviceResponses = {
    /**
     * Successful response
     */
    200: unknown;
};

export type GetLibrariesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/libraries';
};

export type GetLibrariesResponses = {
    /**
     * getLibraries OK
     */
    200: {
        libraries?: Array<Library>;
    };
};

export type GetLibrariesResponse = GetLibrariesResponses[keyof GetLibrariesResponses];

export type CreateLibraryData = {
    /**
     * The library object to create.
     */
    body?: {
        name: LibraryName;
        folders: LibraryFolders;
        displayOrder?: LibraryDisplayOrder;
        icon?: LibraryIcon;
        mediaType?: LibraryMediaType;
        provider?: LibraryProvider;
        settings?: LibrarySettings;
    };
    path?: never;
    query?: never;
    url: '/api/libraries';
};

export type CreateLibraryErrors = {
    /**
     * Library not found.
     */
    404: string;
};

export type CreateLibraryError = CreateLibraryErrors[keyof CreateLibraryErrors];

export type CreateLibraryResponses = {
    /**
     * Library found.
     */
    200: Library;
};

export type CreateLibraryResponse = CreateLibraryResponses[keyof CreateLibraryResponses];

export type DeleteLibraryByIdData = {
    body?: never;
    path: {
        /**
         * The ID of the library.
         */
        id: LibraryId;
    };
    query?: never;
    url: '/api/libraries/{id}';
};

export type DeleteLibraryByIdErrors = {
    /**
     * Library not found.
     */
    404: string;
};

export type DeleteLibraryByIdError = DeleteLibraryByIdErrors[keyof DeleteLibraryByIdErrors];

export type DeleteLibraryByIdResponses = {
    /**
     * Library found.
     */
    200: Library;
};

export type DeleteLibraryByIdResponse = DeleteLibraryByIdResponses[keyof DeleteLibraryByIdResponses];

export type GetLibraryByIdData = {
    body?: never;
    path: {
        /**
         * The ID of the library.
         */
        id: LibraryId;
    };
    query?: {
        include?: string;
        /**
         * Return minified items if true
         */
        minified?: number;
    };
    url: '/api/libraries/{id}';
};

export type GetLibraryByIdErrors = {
    /**
     * Library not found.
     */
    404: string;
};

export type GetLibraryByIdError = GetLibraryByIdErrors[keyof GetLibraryByIdErrors];

export type GetLibraryByIdResponses = {
    /**
     * Library found.
     */
    200: Library;
};

export type GetLibraryByIdResponse = GetLibraryByIdResponses[keyof GetLibraryByIdResponses];

export type UpdateLibraryByIdData = {
    /**
     * The library object to update.
     */
    body: {
        name?: LibraryName;
        folders?: LibraryFolders;
        displayOrder?: LibraryDisplayOrder;
        icon?: LibraryIcon;
        mediaType?: LibraryMediaType;
        provider?: LibraryProvider;
        settings?: LibrarySettings;
    };
    path: {
        /**
         * The ID of the library.
         */
        id: LibraryId;
    };
    query?: never;
    url: '/api/libraries/{id}';
};

export type UpdateLibraryByIdErrors = {
    /**
     * Library not found.
     */
    404: string;
};

export type UpdateLibraryByIdError = UpdateLibraryByIdErrors[keyof UpdateLibraryByIdErrors];

export type UpdateLibraryByIdResponses = {
    /**
     * Library found.
     */
    200: Library;
};

export type UpdateLibraryByIdResponse = UpdateLibraryByIdResponses[keyof UpdateLibraryByIdResponses];

export type GetLibraryAuthorsData = {
    body?: never;
    path: {
        /**
         * The ID of the library.
         */
        id: LibraryId;
    };
    query?: never;
    url: '/api/libraries/{id}/authors';
};

export type GetLibraryAuthorsErrors = {
    /**
     * Library not found.
     */
    404: string;
};

export type GetLibraryAuthorsError = GetLibraryAuthorsErrors[keyof GetLibraryAuthorsErrors];

export type GetLibraryAuthorsResponses = {
    /**
     * getLibraryAuthors OK
     */
    200: {
        authors?: Array<AuthorExpanded>;
    };
};

export type GetLibraryAuthorsResponse = GetLibraryAuthorsResponses[keyof GetLibraryAuthorsResponses];

export type GetLibraryItemsData = {
    body?: never;
    path: {
        /**
         * The ID of the library.
         */
        id: LibraryId;
    };
    query?: {
        /**
         * The number of items to return. This the size of a single page for the optional `page` query.
         */
        limit?: number;
        /**
         * The page number (zero indexed) to return. If no limit is specified, then page will have no effect.
         */
        page?: number;
        /**
         * The field to sort by from the request.
         */
        sort?: string;
        /**
         * Return items in reversed order if true.
         */
        desc?: number;
        /**
         * The filter for the library.
         */
        filter?: string;
        /**
         * The fields to include in the response. The only current option is `rssfeed`.
         */
        include?: string;
        /**
         * Return minified items if true
         */
        minified?: number;
        /**
         * Whether to collapse series into a single cover
         */
        collapseSeries?: number;
    };
    url: '/api/libraries/{id}/items';
};

export type GetLibraryItemsErrors = {
    /**
     * Library not found.
     */
    404: string;
};

export type GetLibraryItemsError = GetLibraryItemsErrors[keyof GetLibraryItemsErrors];

export type GetLibraryItemsResponses = {
    /**
     * getLibraryItems OK
     */
    200: {
        results?: Array<LibraryItemBase>;
        total?: Total;
        limit?: Limit;
        page?: Page;
        sortBy?: SortBy;
        sortDesc?: SortDesc;
        filterBy?: FilterBy;
        mediaType?: MediaType;
        minified?: Minified;
        collapseSeries?: CollapseSeries;
        include?: LibraryInclude;
    };
};

export type GetLibraryItemsResponse = GetLibraryItemsResponses[keyof GetLibraryItemsResponses];

export type DeleteLibraryIssuesData = {
    body?: never;
    path: {
        /**
         * The ID of the library.
         */
        id: LibraryId;
    };
    query?: never;
    url: '/api/libraries/{id}/issues';
};

export type DeleteLibraryIssuesErrors = {
    /**
     * Library not found.
     */
    404: string;
};

export type DeleteLibraryIssuesError = DeleteLibraryIssuesErrors[keyof DeleteLibraryIssuesErrors];

export type DeleteLibraryIssuesResponses = {
    /**
     * deleteLibraryIssues OK
     */
    200: string;
};

export type DeleteLibraryIssuesResponse = DeleteLibraryIssuesResponses[keyof DeleteLibraryIssuesResponses];

export type GetLibrarySeriesData = {
    body?: never;
    path: {
        /**
         * The ID of the library.
         */
        id: LibraryId;
    };
    query?: {
        /**
         * The number of items to return. This the size of a single page for the optional `page` query.
         */
        limit?: number;
        /**
         * The page number (zero indexed) to return. If no limit is specified, then page will have no effect.
         */
        page?: number;
        /**
         * The field to sort by from the request.
         */
        sort?: 'name' | 'numBooks' | 'totalDuration' | 'addedAt' | 'lastBookAdded' | 'lastBookUpdated';
        /**
         * Return items in reversed order if true.
         */
        desc?: number;
        /**
         * The filter for the library.
         */
        filter?: string;
        /**
         * The fields to include in the response. The only current option is `rssfeed`.
         */
        include?: string;
        /**
         * Return minified items if true
         */
        minified?: number;
    };
    url: '/api/libraries/{id}/series';
};

export type GetLibrarySeriesErrors = {
    /**
     * Library not found.
     */
    404: string;
};

export type GetLibrarySeriesError = GetLibrarySeriesErrors[keyof GetLibrarySeriesErrors];

export type GetLibrarySeriesResponses = {
    /**
     * getLibrarySeries OK
     */
    200: {
        results?: Array<SeriesBooks>;
        total?: Total;
        limit?: Limit;
        page?: Page;
        sortBy?: SortBy;
        sortDesc?: SortDesc;
        filterBy?: FilterBy;
        minified?: Minified;
        include?: LibraryInclude;
    };
};

export type GetLibrarySeriesResponse = GetLibrarySeriesResponses[keyof GetLibrarySeriesResponses];

export type GetLibrarySeriesByIdData = {
    body?: never;
    path: {
        /**
         * The ID of the library.
         */
        id: LibraryId;
        /**
         * The ID of the series.
         */
        seriesId: SeriesId;
    };
    query?: {
        /**
         * The number of items to return. This the size of a single page for the optional `page` query.
         */
        limit?: number;
        /**
         * The page number (zero indexed) to return. If no limit is specified, then page will have no effect.
         */
        page?: number;
        /**
         * The field to sort by from the request.
         */
        sort?: 'name' | 'numBooks' | 'totalDuration' | 'addedAt' | 'lastBookAdded' | 'lastBookUpdated';
        /**
         * Return items in reversed order if true.
         */
        desc?: number;
        /**
         * The filter for the library.
         */
        filter?: string;
        /**
         * Return minified items if true
         */
        minified?: number;
        /**
         * The fields to include in the response. The only current option is `rssfeed`.
         */
        include?: string;
    };
    url: '/api/libraries/{id}/series/{seriesId}';
};

export type GetLibrarySeriesByIdErrors = {
    /**
     * Library not found.
     */
    404: string;
};

export type GetLibrarySeriesByIdError = GetLibrarySeriesByIdErrors[keyof GetLibrarySeriesByIdErrors];

export type GetLibrarySeriesByIdResponses = {
    /**
     * getLibrarySeriesById OK
     */
    200: SeriesWithProgressAndRss;
};

export type GetLibrarySeriesByIdResponse = GetLibrarySeriesByIdResponses[keyof GetLibrarySeriesByIdResponses];

export type GetNotificationsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/notifications';
};

export type GetNotificationsErrors = {
    /**
     * An admin user is required or notification with the given ID not found.
     */
    404: string;
};

export type GetNotificationsError = GetNotificationsErrors[keyof GetNotificationsErrors];

export type GetNotificationsResponses = {
    /**
     * Success
     */
    200: {
        data?: {
            events?: Array<NotificationEvent>;
        };
        settings?: NotificationSettings;
    };
};

export type GetNotificationsResponse = GetNotificationsResponses[keyof GetNotificationsResponses];

export type ConfigureNotificationSettingsData = {
    body?: {
        appriseApiUrl?: AppriseApiUrl;
        maxFailedAttempts?: MaxFailedAttempts;
        maxNotificationQueue?: MaxNotificationQueue;
    };
    path?: never;
    query?: never;
    url: '/api/notifications';
};

export type ConfigureNotificationSettingsErrors = {
    /**
     * An admin user is required or notification with the given ID not found.
     */
    404: string;
};

export type ConfigureNotificationSettingsError = ConfigureNotificationSettingsErrors[keyof ConfigureNotificationSettingsErrors];

export type ConfigureNotificationSettingsResponses = {
    /**
     * Notification endpoint success.
     */
    200: string;
};

export type ConfigureNotificationSettingsResponse = ConfigureNotificationSettingsResponses[keyof ConfigureNotificationSettingsResponses];

export type CreateNotificationData = {
    body?: {
        libraryId?: LibraryIdNullable;
        eventName: NotificationEventName;
        urls: Urls;
        titleTemplate: TitleTemplate;
        bodyTemplate: BodyTemplate;
        enabled?: Enabled;
        type?: NotificationType;
    };
    path?: never;
    query?: never;
    url: '/api/notifications';
};

export type CreateNotificationErrors = {
    /**
     * An admin user is required or notification with the given ID not found.
     */
    404: string;
};

export type CreateNotificationError = CreateNotificationErrors[keyof CreateNotificationErrors];

export type CreateNotificationResponses = {
    /**
     * Success
     */
    200: {
        settings?: NotificationSettings;
    };
};

export type CreateNotificationResponse = CreateNotificationResponses[keyof CreateNotificationResponses];

export type GetNotificationEventDataData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/notificationdata';
};

export type GetNotificationEventDataErrors = {
    /**
     * An admin user is required or notification with the given ID not found.
     */
    404: string;
};

export type GetNotificationEventDataError = GetNotificationEventDataErrors[keyof GetNotificationEventDataErrors];

export type GetNotificationEventDataResponses = {
    /**
     * Success
     */
    200: {
        events?: Array<NotificationEvent>;
    };
};

export type GetNotificationEventDataResponse = GetNotificationEventDataResponses[keyof GetNotificationEventDataResponses];

export type SendDefaultTestNotificationData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Whether to intentionally cause the notification to fail. `0` for false, `1` for true.
         */
        fail?: number;
    };
    url: '/api/notifications/test';
};

export type SendDefaultTestNotificationErrors = {
    /**
     * An admin user is required or notification with the given ID not found.
     */
    404: string;
};

export type SendDefaultTestNotificationError = SendDefaultTestNotificationErrors[keyof SendDefaultTestNotificationErrors];

export type SendDefaultTestNotificationResponses = {
    /**
     * Notification endpoint success.
     */
    200: string;
};

export type SendDefaultTestNotificationResponse = SendDefaultTestNotificationResponses[keyof SendDefaultTestNotificationResponses];

export type DeleteNotificationData = {
    body?: never;
    path: {
        /**
         * The ID of the notification.
         */
        id: NotificationId;
    };
    query?: never;
    url: '/api/notifications/{id}';
};

export type DeleteNotificationErrors = {
    /**
     * An admin user is required or notification with the given ID not found.
     */
    404: string;
};

export type DeleteNotificationError = DeleteNotificationErrors[keyof DeleteNotificationErrors];

export type DeleteNotificationResponses = {
    /**
     * Success
     */
    200: {
        settings?: NotificationSettings;
    };
};

export type DeleteNotificationResponse = DeleteNotificationResponses[keyof DeleteNotificationResponses];

export type UpdateNotificationData = {
    body?: {
        libraryId?: LibraryId;
        eventName?: NotificationEventName;
        urls?: Urls;
        titleTemplate?: TitleTemplate;
        bodyTemplate?: BodyTemplate;
        enabled?: Enabled;
        type?: NotificationType;
    };
    path: {
        /**
         * The ID of the notification.
         */
        id: NotificationId;
    };
    query?: never;
    url: '/api/notifications/{id}';
};

export type UpdateNotificationErrors = {
    /**
     * An admin user is required or notification with the given ID not found.
     */
    404: string;
};

export type UpdateNotificationError = UpdateNotificationErrors[keyof UpdateNotificationErrors];

export type UpdateNotificationResponses = {
    /**
     * Success
     */
    200: {
        settings?: NotificationSettings;
    };
};

export type UpdateNotificationResponse = UpdateNotificationResponses[keyof UpdateNotificationResponses];

export type SendTestNotificationData = {
    body?: never;
    path: {
        /**
         * The ID of the notification.
         */
        id: NotificationId;
    };
    query?: never;
    url: '/api/notifications/{id}/test';
};

export type SendTestNotificationErrors = {
    /**
     * An admin user is required or notification with the given ID not found.
     */
    404: string;
};

export type SendTestNotificationError = SendTestNotificationErrors[keyof SendTestNotificationErrors];

export type SendTestNotificationResponses = {
    /**
     * Notification endpoint success.
     */
    200: string;
};

export type SendTestNotificationResponse = SendTestNotificationResponses[keyof SendTestNotificationResponses];

export type CreatePodcastData = {
    body: Podcast;
    path?: never;
    query?: never;
    url: '/api/podcasts';
};

export type CreatePodcastErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Not found
     */
    404: unknown;
};

export type CreatePodcastResponses = {
    /**
     * Successfully created a podcast
     */
    200: Podcast;
};

export type CreatePodcastResponse = CreatePodcastResponses[keyof CreatePodcastResponses];

export type GetPodcastFeedData = {
    body: {
        /**
         * The RSS feed URL of the podcast
         */
        rssFeed?: string;
    };
    path?: never;
    query?: never;
    url: '/api/podcasts/feed';
};

export type GetPodcastFeedErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Not found
     */
    404: unknown;
};

export type GetPodcastFeedResponses = {
    /**
     * Successfully retrieved podcast feed
     */
    200: {
        podcast?: Podcast;
    };
};

export type GetPodcastFeedResponse = GetPodcastFeedResponses[keyof GetPodcastFeedResponses];

export type GetFeedsFromOpmlTextData = {
    body?: {
        opmlText?: string;
    };
    path?: never;
    query?: never;
    url: '/api/podcasts/opml/parse';
};

export type GetFeedsFromOpmlTextErrors = {
    /**
     * Bad request, OPML text not provided
     */
    400: unknown;
    /**
     * Forbidden, user is not admin
     */
    403: unknown;
};

export type GetFeedsFromOpmlTextResponses = {
    /**
     * Successfully parsed OPML text and returned feeds
     */
    200: {
        feeds?: Array<{
            title?: string;
            feedUrl?: string;
        }>;
    };
};

export type GetFeedsFromOpmlTextResponse = GetFeedsFromOpmlTextResponses[keyof GetFeedsFromOpmlTextResponses];

export type BulkCreatePodcastsFromOpmlFeedUrlsData = {
    body?: {
        feeds?: Array<string>;
        libraryId?: LibraryId;
        folderId?: FolderId;
        autoDownloadEpisodes?: AutoDownloadEpisodes;
    };
    path?: never;
    query?: never;
    url: '/api/podcasts/opml/create';
};

export type BulkCreatePodcastsFromOpmlFeedUrlsErrors = {
    /**
     * Bad request, invalid request body
     */
    400: unknown;
    /**
     * Forbidden, user is not admin
     */
    403: unknown;
    /**
     * Folder not found
     */
    404: unknown;
};

export type BulkCreatePodcastsFromOpmlFeedUrlsResponses = {
    /**
     * Successfully created podcasts from feed URLs
     */
    200: unknown;
};

export type CheckNewEpisodesData = {
    body?: never;
    path: {
        /**
         * Podcast ID
         */
        id: PodcastId;
    };
    query?: {
        /**
         * Maximum number of episodes to download
         */
        limit?: number;
    };
    url: '/api/podcasts/{id}/checknew';
};

export type CheckNewEpisodesErrors = {
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: unknown;
};

export type CheckNewEpisodesResponses = {
    /**
     * Successfully checked and downloaded new episodes
     */
    200: {
        episodes?: Array<PodcastEpisode>;
    };
};

export type CheckNewEpisodesResponse = CheckNewEpisodesResponses[keyof CheckNewEpisodesResponses];

export type ClearEpisodeDownloadQueueData = {
    body?: never;
    path: {
        /**
         * Podcast ID
         */
        id: PodcastId;
    };
    query?: never;
    url: '/api/podcasts/{id}/clear-queue';
};

export type ClearEpisodeDownloadQueueErrors = {
    /**
     * Forbidden
     */
    403: unknown;
};

export type ClearEpisodeDownloadQueueResponses = {
    /**
     * Successfully cleared download queue
     */
    200: unknown;
};

export type GetEpisodeDownloadsData = {
    body?: never;
    path: {
        /**
         * Podcast ID
         */
        id: PodcastId;
    };
    query?: never;
    url: '/api/podcasts/{id}/downloads';
};

export type GetEpisodeDownloadsErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type GetEpisodeDownloadsResponses = {
    /**
     * Successfully retrieved episode downloads
     */
    200: {
        downloads?: Array<PodcastEpisode>;
    };
};

export type GetEpisodeDownloadsResponse = GetEpisodeDownloadsResponses[keyof GetEpisodeDownloadsResponses];

export type FindEpisodeData = {
    body?: never;
    path: {
        /**
         * Podcast ID
         */
        id: PodcastId;
    };
    query: {
        /**
         * Title of the episode to search for
         */
        title: string;
    };
    url: '/api/podcasts/{id}/search-episode';
};

export type FindEpisodeErrors = {
    /**
     * Not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: unknown;
};

export type FindEpisodeResponses = {
    /**
     * Successfully found episodes
     */
    200: {
        episodes?: Array<PodcastEpisode>;
    };
};

export type FindEpisodeResponse = FindEpisodeResponses[keyof FindEpisodeResponses];

export type DownloadEpisodesData = {
    body: Array<string>;
    path: {
        /**
         * Podcast ID
         */
        id: PodcastId;
    };
    query?: never;
    url: '/api/podcasts/{id}/download-episodes';
};

export type DownloadEpisodesErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type DownloadEpisodesResponses = {
    /**
     * Successfully started episode download
     */
    200: unknown;
};

export type QuickMatchEpisodesData = {
    body?: never;
    path: {
        /**
         * Podcast ID
         */
        id: PodcastId;
    };
    query?: {
        /**
         * Override existing details if set to 1
         */
        override?: string;
    };
    url: '/api/podcasts/{id}/match-episodes';
};

export type QuickMatchEpisodesErrors = {
    /**
     * Forbidden
     */
    403: unknown;
};

export type QuickMatchEpisodesResponses = {
    /**
     * Successfully matched episodes
     */
    200: {
        numEpisodesUpdated?: number;
    };
};

export type QuickMatchEpisodesResponse = QuickMatchEpisodesResponses[keyof QuickMatchEpisodesResponses];

export type RemoveEpisodeData = {
    body?: never;
    path: {
        /**
         * Podcast ID
         */
        id: PodcastId;
        /**
         * Episode ID
         */
        episodeId: PodcastId;
    };
    query?: {
        /**
         * Hard delete the episode if set to 1
         */
        hard?: string;
    };
    url: '/api/podcasts/{id}/episode/{episodeId}';
};

export type RemoveEpisodeErrors = {
    /**
     * Not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: unknown;
};

export type RemoveEpisodeResponses = {
    /**
     * Successfully removed episode
     */
    200: Podcast;
};

export type RemoveEpisodeResponse = RemoveEpisodeResponses[keyof RemoveEpisodeResponses];

export type GetEpisodeData = {
    body?: never;
    path: {
        /**
         * Podcast ID
         */
        id: PodcastId;
        /**
         * Episode ID
         */
        episodeId: PodcastId;
    };
    query?: never;
    url: '/api/podcasts/{id}/episode/{episodeId}';
};

export type GetEpisodeErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type GetEpisodeResponses = {
    /**
     * Successfully retrieved episode
     */
    200: PodcastEpisode;
};

export type GetEpisodeResponse = GetEpisodeResponses[keyof GetEpisodeResponses];

export type UpdateEpisodeData = {
    body: {
        [key: string]: unknown;
    };
    path: {
        /**
         * Podcast ID
         */
        id: PodcastId;
        /**
         * Episode ID
         */
        episodeId: PodcastId;
    };
    query?: never;
    url: '/api/podcasts/{id}/episode/{episodeId}';
};

export type UpdateEpisodeErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type UpdateEpisodeResponses = {
    /**
     * Successfully updated episode
     */
    200: Podcast;
};

export type UpdateEpisodeResponse = UpdateEpisodeResponses[keyof UpdateEpisodeResponses];

export type GetSeriesData = {
    /**
     * A comma separated list of what to include with the series.
     */
    body?: {
        /**
         * A comma separated list of what to include with the series.
         */
        include?: 'progress' | 'rssfeed' | 'progress,rssfeed' | 'rssfeed,progress';
    };
    path: {
        /**
         * The ID of the series.
         */
        id: SeriesId;
    };
    query?: never;
    url: '/api/series/{id}';
};

export type GetSeriesErrors = {
    /**
     * Series not found.
     */
    404: string;
};

export type GetSeriesError = GetSeriesErrors[keyof GetSeriesErrors];

export type GetSeriesResponses = {
    /**
     * OK
     */
    200: SeriesWithProgressAndRss;
};

export type GetSeriesResponse = GetSeriesResponses[keyof GetSeriesResponses];

export type UpdateSeriesData = {
    /**
     * The series to update.
     */
    body: {
        name?: SeriesName;
        description?: SeriesDescription;
    };
    path: {
        /**
         * The ID of the series.
         */
        id: SeriesId;
    };
    query?: never;
    url: '/api/series/{id}';
};

export type UpdateSeriesErrors = {
    /**
     * Series not found.
     */
    404: string;
};

export type UpdateSeriesError = UpdateSeriesErrors[keyof UpdateSeriesErrors];

export type UpdateSeriesResponses = {
    /**
     * OK
     */
    200: Series;
};

export type UpdateSeriesResponse = UpdateSeriesResponses[keyof UpdateSeriesResponses];

export type ClientOptions = {
    baseUrl: 'http://localhost:3000' | (string & {});
};